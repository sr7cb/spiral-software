# -*- Mode: shell-script -*- 

GlobalPackage(gap.rat);
#############################################################################
##
#A  rational.g                  GAP library                  Martin Schoenert
##
##
#Y  Copyright (C) 2018-2021, Carnegie Mellon University
#Y  All rights reserved.  See LICENSE for details.
#Y  
#Y  This work is based on GAP version 3, with some files from version 4.  GAP is
#Y  Copyright (C) (1987--2021) by the GAP Group (www.gap-system.org).
##
##  This file contains  those  functions  that  mainly  deal  with rationals.
##
##


#############################################################################
##
#F  Rationals . . . . . . . . . . . . . . . . . . . . . .  field of rationals
#F  RationalsOps  . . . . . . . . . . . . operations record for the rationals
##
RationalsOps := OperationsRecord( "RationalsOps", FieldOps );

Rationals := rec(
    isDomain                    := true,
    isField                     := true,
    isCyclotomicField           := true,

    char                        := 0,
    generators                  := [ 1 ],
    zero                        := 0,
    one                         := 1,
    name                        := "Rationals",

    size                        := "infinity",
    isFinite                    := false,
    degree                      := 1,

    field                       := 0,
    dimension                   := 1,
    base                        := [ 1 ],
    automorphisms               := [ e -> e ],

    operations                  := RationalsOps
);


#############################################################################
##
#F  RationalsOps.Field(<elms>)  . . . . . . field generated by some rationals
##
RationalsOps.Field := function ( elms )
    return Rationals;
end;


#############################################################################
##
#F  RationalsOps.DefaultField(<elms>) . . . . default field of some rationals
##
RationalsOps.DefaultField := function ( elms )
    return Rationals;
end;


#############################################################################
##
#F  RationalsOps.\in(<x>,<Rationals>)  . . . . membership test for rationals
##
RationalsOps.\in := function ( x, Rationals )
    return IsRat( x );
end;


#############################################################################
##
#F  RationalsOps.Random(<Rationals>)  . . . . . . . . . . . . random rational
##
RationalsOps.Random := function ( Rationals )
    local    num, den;
    num := Random( Integers );
    repeat
        den := Random( Integers );
    until den <> 0;
    return num / den;
end;


#############################################################################
##
#F  RationalOps.Conjugates(<Rationals>,<x>) . . . .  conjugates of a rational
##
RationalsOps.Conjugates := function ( Rationals, x )
    return [ x ];
end;


#############################################################################
##
#F  RationalsOps.AsGroup(<Rationals>) . . . rationals as multiplicative group
##
RationalsOps.AsGroup := function ( Rationals )
    Error("the multiplicative group of Q is not finitely generated");
end;


#############################################################################
##
#F  RationalsOps.AsAdditiveGroup(<Rationals>) . . rationals as additive group
##
RationalsOps.AsAdditiveGroup := function ( Rationals )
    Error("the additive group of Q is not finitely generated");
end;


#############################################################################
##
#F  RationalsOps.AsRing(<Rationals>)  . . . . . .  view the rationals as ring
##
#N  23-Oct-91 martin this should be 'FieldOps.AsRing'
##
RationalsAsRingOps := OperationsRecord( "RationalsAsRingOps", RingOps );

RationalsAsRingOps.\in := RationalsOps.\in;

RationalsAsRingOps.Random := RationalsOps.Random;

RationalsAsRingOps.Quotient := function ( R, r, s )
    return r/s;
end;

RationalsAsRingOps.IsUnit := function ( R, r )
    return r <> R.zero;
end;

RationalsAsRingOps.Units := function ( R )
    return AsGroup( R.field );
end;

RationalsAsRingOps.IsAssociated := function ( R, r, s )
    return (r = R.zero) = (s = R.zero);
end;

RationalsAsRingOps.StandardAssociate := function ( R, r )
    if r = R.zero  then
        return R.zero;
    else
        return R.one;
    fi;
end;

RationalsOps.AsRing := function ( Rationals )

    return rec(
        isDomain                := true,
        isRing                  := true,

        zero                    := 0,
        one                     := 1,

        isFinite                := false,
        size                    := "infinity",
        isCommutativeRing       := true,
        isIntegralRing          := true,
        field                   := Rationals,

        operations              := RationalsAsRingOps
    );
end;


#############################################################################
##
#F  RationalsOps.PolynomialRing( <R> )  . . . . . . . .  full polynomial ring
##
RationalsOps.PolynomialRing := function( R )
    return RationalsPolynomials;
end;


#############################################################################
##
#F  RationalsOps.Polynomial( <R>, <coeffs>, <val> ) . . . polynomial over <R>
##
RationalsOps.Polynomial := function( R, coeffs, val )

    # normalize <coeffs>
    coeffs := ShallowCopy(coeffs);
    val    := val + NormalizeCoeffs(coeffs);
    if 0 = Length(coeffs)  then val := 0;  fi;

    # return polynomial
    if val < 0  then
        return rec( coefficients := coeffs,
    	    	    baseRing     := R,
    	    	    isPolynomial := true,
		    valuation    := val,
    	    	    domain       := LaurentPolynomials,
    	    	    operations   := RationalsPolynomialOps );
    else
        return rec( coefficients := coeffs,
    	    	    baseRing     := R,
    	    	    isPolynomial := true,
		    valuation    := val,
    	    	    domain       := RationalsPolynomials,
    	    	    operations   := RationalsPolynomialOps );
    fi;

end;


#############################################################################
##
#F  RationalsOps.FastPolynomial( <R>, <coeffs>, <val> ) . polynomial over <R>
##
##  This function will *not* copy <coeffs> and thus destroy <coeffs>.
##
RationalsOps.FastPolynomial := function( R, coeffs, val )

    # normalize <coeffs>
    val := val + NormalizeCoeffs(coeffs);
    if 0 = Length(coeffs)  then val := 0;  fi;

    # return polynomial
    if val < 0  then
        return rec( coefficients := coeffs,
    	    	    baseRing     := R,
    	    	    isPolynomial := true,
		    valuation    := val,
    	    	    domain       := LaurentPolynomials,
    	    	    operations   := RationalsPolynomialOps );
    else
        return rec( coefficients := coeffs,
    	    	    baseRing     := R,
    	    	    isPolynomial := true,
		    valuation    := val,
    	    	    domain       := RationalsPolynomials,
    	    	    operations   := RationalsPolynomialOps );
    fi;

end;
